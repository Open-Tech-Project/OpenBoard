import { OpenBoardTheme } from '../model/Theme';
import {
  arabicLayout,
  englishLayout,
  italianLayout,
  KeyAction,
  KeyboardLayout,
  KeyData,
  polishLayout,
  ShiftState,
  symbolsLayout1,
  symbolsLayout2,
  persianLayout
} from '../model/KeyboardKeyData';
import keyboardController from '../model/KeyboardController';
import predictionModel from '../model/PredictionModel';
import { display } from '@kit.ArkUI';
import { inputMethodEngine } from '@kit.IMEKit';
import pasteboard from '@ohos.pasteboard';

const EMOJI_KEY_DATA: KeyData = { mainValue: 'icon', secondaryValue: undefined, action: KeyAction.EMOJI_PANEL, flex: 1.2, shiftValue: undefined };

// TYPE DEFINITIONS
interface Position { x: number; y: number; }
interface LongPressInfo { key: KeyData; initialPosition: Position; }
interface SingleCharPopupInfo { char: string; position: Position; }
type LanguageCode = 'en' | 'ar' | 'it' | 'pl' | 'fa';
enum LayoutSwipeDirection { Left, Right }
const ALLOWED_LANGUAGES: string[] = ['en', 'ar', 'it', 'pl', 'fa'];
const EMOJI_CATEGORIES: string[] = ['Smileys & Emotion', 'People', 'Animals & Nature', 'Food & Drink', 'Activity & Event', 'Travel & Places', 'Objects', 'Symbols', 'Flags'];

// Speech recognition simulation types
interface SpeechRecognitionResult {
  text: string;
  delay: number;
}

// HELPER FUNCTIONS
function getLanguageName(code: LanguageCode): string {
  switch (code) {
    case 'ar': return 'Arabic';
    case 'en': return 'English';
    case 'it': return 'Italian';
    case 'pl': return 'Polish';
    case 'fa': return 'Persian';
    default: return 'English';
  }
}

function getVoiceDictationStatus(code: LanguageCode): string {
  switch (code) {
    case 'en': return 'Voice typing...';
    case 'pl': return 'Piszenie gÅ‚osem...';
    case 'it': return 'Digitazione vocale...';
    case 'ar': return 'Ø§Ù„ÙƒØªØ§Ø¨Ø© Ø§Ù„ØµÙˆØªÙŠØ©...';
    case 'fa': return 'ØªØ§ÛŒÙ¾ ØµÙˆØªÛŒ...';
    default: return 'Voice typing...';
  }
}

// Voice interruption error messages in different languages
function getVoiceInterruptionMessage(code: LanguageCode): string {
  switch (code) {
    case 'en': return 'Voice input interrupted';
    case 'pl': return 'Wprowadzanie gÅ‚osowe przerwane';
    case 'it': return 'Inserimento vocale interrotto';
    case 'ar': return 'ØªÙ… Ù…Ù‚Ø§Ø·Ø¹Ø© Ø§Ù„Ø¥Ø¯Ø®Ø§Ù„ Ø§Ù„ØµÙˆØªÙŠ';
    case 'fa': return 'ÙˆØ±ÙˆØ¯ÛŒ ØµÙˆØªÛŒ Ù‚Ø·Ø¹ Ø´Ø¯';
    default: return 'Voice input interrupted';
  }
}

function getVoicePermissionError(code: LanguageCode): string {
  switch (code) {
    case 'en': return 'Microphone permission denied';
    case 'pl': return 'Odmowa uprawnieÅ„ do mikrofonu';
    case 'it': return 'Permesso microfono negato';
    case 'ar': return 'ØªÙ… Ø±ÙØ¶ Ø¥Ø°Ù† Ø§Ù„Ù…ÙŠÙƒØ±ÙˆÙÙˆÙ†';
    case 'fa': return 'Ø§Ø¬Ø§Ø²Ù‡ Ù…ÛŒÚ©Ø±ÙˆÙÙˆÙ† Ø±Ø¯ Ø´Ø¯';
    default: return 'Microphone permission denied';
  }
}

function getVoiceRecognitionError(code: LanguageCode): string {
  switch (code) {
    case 'en': return 'Speech recognition failed';
    case 'pl': return 'Rozpoznawanie mowy nie powiodÅ‚o siÄ™';
    case 'it': return 'Riconoscimento vocale fallito';
    case 'ar': return 'ÙØ´Ù„ Ø§Ù„ØªØ¹Ø±Ù Ø¹Ù„Ù‰ Ø§Ù„ÙƒÙ„Ø§Ù…';
    case 'fa': return 'ØªØ´Ø®ÛŒØµ Ú¯ÙØªØ§Ø±å¤±æ•— Ø´Ø¯';
    default: return 'Speech recognition failed';
  }
}

// COMPONENTS
@Component
struct KeyPopup {
  @Prop info: LongPressInfo;
  @Prop hoveredChar: string | null;
  @Prop keyWidth: number;
  build() {
    Row({ space: 8 }) {
      ForEach((this.info.key.secondaryValue ?? '').split(','), (char: string) => {
        Text(char)
          .fontSize(22)
          .fontWeight(500)
          .fontColor(OpenBoardTheme.primaryText)
          .width(this.keyWidth)
          .height(50)
          .textAlign(TextAlign.Center)
          .backgroundColor(char === this.hoveredChar ? OpenBoardTheme.accent : OpenBoardTheme.specialKey)
          .borderRadius(8)
          .animation({ duration: 50 })
      })
    }
    .padding({ left: 8, right: 8, top: 6, bottom: 6 })
    .backgroundColor(OpenBoardTheme.surface)
    .borderRadius(12)
    .shadow({ radius: 10, color: '#60000000', offsetY: 4 })
  }
}

@Component
struct SingleKeyPopup {
  @Prop char: string;
  build() {
    Column() {
      Text(this.char)
        .fontSize(24)
        .fontWeight(400)
        .fontColor(OpenBoardTheme.primaryText)
    }
    .width(50)
    .height(60)
    .justifyContent(FlexAlign.Center)
    .backgroundColor(OpenBoardTheme.surface)
    .borderRadius(12)
  }
}

@Component
struct LanguageIndicator {
  @Prop languageName: string;
  build() {
    Column() {
      Text(this.languageName)
        .fontSize(28)
        .fontWeight(500)
        .fontColor('#FFFFFF')
        .padding({ left: 24, right: 24, top: 12, bottom: 12 })
    }
    .backgroundColor('rgba(0, 0, 0, 0.85)')
    .borderRadius(16)
    .shadow({ radius: 20, color: '#40000000', offsetY: 4 })
  }
}

@Component
struct VoiceInterruptionPopup {
  @Prop message: string;
  @Prop popupPosition: Position;

  build() {
    Column() {
      Text(this.message)
        .fontSize(16)
        .fontWeight(500)
        .fontColor(OpenBoardTheme.primaryText)
        .padding({ left: 16, right: 16, top: 12, bottom: 12 })
    }
    .backgroundColor(OpenBoardTheme.surface)
    .borderRadius(12)
    .border({ width: 1, color: OpenBoardTheme.divider })
    .shadow({ radius: 10, color: '#40000000', offsetY: 4 })
    .position({ x: this.popupPosition.x, y: this.popupPosition.y })
  }
}

@Component
struct KeyView {
  @Prop keyData: KeyData;
  @Prop shiftState: ShiftState;
  @Prop currentLanguage: LanguageCode;
  @Prop availableLanguages: LanguageCode[];
  onKeyPress: (key: KeyData) => void = () => {};
  onKeyLongPress: (key: KeyData, position: Position) => void = () => {};
  onKeyLongPressDrag: (position: Position) => void = () => {};
  onKeyLongPressEnd: () => void = () => {};
  onKeyContinuousPressStart: (key: KeyData) => void = () => {};
  onKeyContinuousPressEnd: (key: KeyData) => void = () => {};
  onSwipe?: (direction: LayoutSwipeDirection) => void;

  @State isPressed: boolean = false;
  @State private longPressTimer: number = -1;
  @State private longPressTriggered: boolean = false;
  @State private touchStartX: number = 0;
  @State private swipeHandled: boolean = false;

  @Prop enterKeyLabel: string;

  getDisplayValue(): string {
    if (this.keyData.action === KeyAction.Shift) {
      return '';
    }
    if (this.keyData.action === KeyAction.Enter) {
      if (this.enterKeyLabel === 'Search' || this.enterKeyLabel === 'Send') {
        return '';
      }
      return this.enterKeyLabel;
    }
    if (this.currentLanguage !== 'ar' && this.currentLanguage !== 'fa' && (this.shiftState === ShiftState.On || this.shiftState === ShiftState.CapsLock)) {
      return this.keyData.shiftValue ?? this.keyData.mainValue;
    }
    if (this.keyData.action === KeyAction.Space) {
      if (this.availableLanguages && this.availableLanguages.length > 1) {
        return getLanguageName(this.currentLanguage);
      }
      return '';
    }
    if (this.keyData.mainValue === 'icon') {
      return '';
    }
    return this.keyData.mainValue;
  }

  build() {
    Flex({ justifyContent: FlexAlign.Center, alignItems: ItemAlign.Center }) {
      Stack({ alignContent: Alignment.TopEnd }) {
        Column() {
          if (this.keyData.mainValue === 'icon' ||
            (this.keyData.action === KeyAction.Shift) ||
            (this.keyData.action === KeyAction.Enter && (this.enterKeyLabel === 'Search' || this.enterKeyLabel === 'Send'))) {

            if (this.keyData.action === KeyAction.Shift) {
              Image($r('app.media.shift_icon'))
                .width(20)
                .height(20)
                .fillColor(this.shiftState !== ShiftState.Off ? OpenBoardTheme.accent : OpenBoardTheme.primaryText)
            } else if (this.keyData.action === KeyAction.Enter && this.enterKeyLabel === 'Search') {
              Image($r('app.media.search_icon'))
                .width(20)
                .height(20)
            } else if (this.keyData.action === KeyAction.Enter && this.enterKeyLabel === 'Send') {
              Image($r('app.media.send_icon'))
                .width(20)
                .height(20)
            } else if (this.keyData.mainValue === 'icon') {
              Image($r('app.media.emoji_icon'))
                .width(20)
                .height(20)
            }
          } else {
            Text(this.getDisplayValue())
              .fontSize(20)
              .fontWeight(this.keyData.action === KeyAction.Char ? 400 : 500)
              .fontColor(OpenBoardTheme.primaryText)
          }
        }
        .width('100%')
        .height('100%')
        .justifyContent(FlexAlign.Center)
        .alignItems(HorizontalAlign.Center)

        if (this.keyData.secondaryValue) {
          Text(this.keyData.secondaryValue.split(',')[0])
            .fontSize(10)
            .fontColor(OpenBoardTheme.secondaryText)
            .margin({ top: 4, right: 4 })
        }
      }
      .width('100%')
      .height('100%')
      .backgroundColor(this.isPressed ?
        OpenBoardTheme.surface : (this.keyData.action === KeyAction.Char ? OpenBoardTheme.regularKey : OpenBoardTheme.specialKey))
      .borderRadius(8)
      .shadow(this.isPressed ? { radius: 10, color: '#80000000', offsetX: 0, offsetY: 2 } : { radius: 0 })
      .zIndex(this.isPressed ? 100 : 0)
      .animation({ duration: 100 })
      .onTouch((event) => {
        const touch = event.touches[0];
        if (!touch) return;
        const currentPosition: Position = { x: touch.windowX, y: touch.windowY };

        if (event.type === TouchType.Down) {
          this.touchStartX = currentPosition.x;
          this.isPressed = true;
          this.longPressTriggered = false;
          this.swipeHandled = false;

          this.longPressTimer = setTimeout(() => {
            this.longPressTriggered = true;
            this.isPressed = false;

            if (this.keyData.action === KeyAction.Backspace) {
              this.onKeyContinuousPressStart(this.keyData);
            } else if (this.keyData.secondaryValue) {
              this.onKeyLongPress(this.keyData, currentPosition);
            } else if (this.keyData.action === KeyAction.Shift) {
              this.onKeyLongPress(this.keyData, currentPosition);
            }
          }, 500);
        }

        if (event.type === TouchType.Move) {
          if (this.longPressTriggered && this.keyData.secondaryValue) {
            this.onKeyLongPressDrag(currentPosition);
          }

          if (this.keyData.action === KeyAction.Space) {
            const swipeDistance = Math.abs(currentPosition.x - this.touchStartX);
            const SWIPE_THRESHOLD = 30;

            if (!this.swipeHandled && swipeDistance > SWIPE_THRESHOLD) {
              clearTimeout(this.longPressTimer);
              this.longPressTriggered = true;
              this.swipeHandled = true;

              if (this.onSwipe) {
                const direction = (currentPosition.x - this.touchStartX) > 0
                  ? LayoutSwipeDirection.Right
                  : LayoutSwipeDirection.Left;
                this.onSwipe(direction);
              }

              this.isPressed = false;
            }
          }
        }

        if (event.type === TouchType.Up || event.type === TouchType.Cancel) {
          clearTimeout(this.longPressTimer);
          if (this.longPressTriggered) {
            if (this.keyData.action === KeyAction.Backspace) {
              this.onKeyContinuousPressEnd(this.keyData);
            } else if (this.keyData.secondaryValue) {
              this.onKeyLongPressEnd();
            }
          } else if (event.type === TouchType.Up && !this.longPressTriggered) {
            this.onKeyPress(this.keyData);
          }

          this.isPressed = false;
          this.longPressTriggered = false;
          this.touchStartX = 0;
          this.swipeHandled = false;
        }
      })
    }
    .padding({ left: 2, right: 2, top: 2, bottom: 2 })
  }
}

@Entry
@Component
struct Index {
  @State currentLanguage: LanguageCode = 'en';
  @State shiftState: ShiftState = ShiftState.Off;
  @State lastShiftTapTs: number = 0;
  @State keyboardLayout: KeyboardLayout = KeyboardLayout.Alphabet;
  @State longPressInfo: LongPressInfo | null = null;
  @State singleCharPopupInfo: SingleCharPopupInfo | null = null;
  @State hoveredChar: string | null = null;
  @State popupPosition: Position = { x: 0, y: 0 };
  @State popupKeyWidth: number = 40;
  @State rapidDeleteTimer: number = -1;
  @State enterKeyLabel: string = 'Enter';
  @State availableLanguages: LanguageCode[] = ['en'];

  @State showEmojiPanel: boolean = false;
  @State emojiCategory: string = 'Smileys & Emotion';
  private emojiScroller: Scroller = new Scroller();

  @State private previousWord: string = '';
  @State private currentWord: string = '';
  @State private suggestions: string[] = ['', '', ''];

  @State private isRecording: boolean = false;
  @State private languageIndicatorOpacity: number = 0;

  // Speech recognition states
  @State private recognizedText: string = '';
  @State private isListening: boolean = false;
  @State private speechError: string = '';

  // Voice interruption popup state
  @State private showInterruptionPopup: boolean = false;
  @State private interruptionMessage: string = '';
  @State private interruptionPopupPosition: Position = { x: 0, y: 0 };
  private interruptionPopupTimer: number = -1;

  // Speech recognition simulation
  private speechRecognitionTimer: number = -1;
  private currentRecognitionIndex: number = 0;

  // Timer for inactivity detection
  @State private inactivityTimer: number = -1;
  @State private showPreTypingToolbar: boolean = true;
  @State private lastTypingActivity: number = Date.now();

  // Show interruption popup
  private showVoiceInterruptionPopup(message: string): void {
    this.interruptionMessage = message;
    this.showInterruptionPopup = true;

    // Position the popup near the microphone button
    this.interruptionPopupPosition = {
      x: this.getScreenWidthVp() - 150,
      y: 100
    };

    // Auto-hide after 3 seconds
    if (this.interruptionPopupTimer !== -1) {
      clearTimeout(this.interruptionPopupTimer);
    }
    this.interruptionPopupTimer = setTimeout(() => {
      this.showInterruptionPopup = false;
      this.interruptionPopupTimer = -1;
    }, 3000);
  }

  // Speech recognition methods
  private async startVoiceRecognition(): Promise<void> {
    try {
      console.info('Starting voice recognition for language:', this.currentLanguage);

      // Check microphone permission (simulated)
      const permissionGranted = await this.requestMicrophonePermission();
      if (!permissionGranted) {
        this.speechError = getVoicePermissionError(this.currentLanguage);
        this.isRecording = false;
        this.showVoiceInterruptionPopup(this.speechError);
        return;
      }

      this.isListening = true;
      this.recognizedText = '';
      this.speechError = '';
      this.currentRecognitionIndex = 0;

      // Start speech recognition simulation
      this.simulateSpeechRecognition();

    } catch (error) {
      console.error('Failed to start voice recognition:', error);
      this.speechError = getVoiceRecognitionError(this.currentLanguage);
      this.isRecording = false;
      this.isListening = false;
      this.showVoiceInterruptionPopup(this.speechError);
    }
  }

  private async stopVoiceRecognition(): Promise<void> {
    try {
      console.info('Stopping voice recognition');
      this.isListening = false;

      // Clear any ongoing recognition
      if (this.speechRecognitionTimer !== -1) {
        clearTimeout(this.speechRecognitionTimer);
        this.speechRecognitionTimer = -1;
      }

      // Insert recognized text
      if (this.recognizedText.trim()) {
        keyboardController.insertText(this.recognizedText + ' ');
        this.onTextTyped(this.recognizedText + ' ');
      }

      this.recognizedText = '';
      this.currentRecognitionIndex = 0;

    } catch (error) {
      console.error('Error stopping voice recognition:', error);
    }
  }

  private async requestMicrophonePermission(): Promise<boolean> {
    try {
      console.info('Requesting microphone permission');
      return true; // Assume granted for demonstration
    } catch (error) {
      console.error('Permission request error:', error);
      return false;
    }
  }

  // Simulated speech recognition for demonstration
  private simulateSpeechRecognition(): void {
    // Define simulated results with proper typing
    const simulatedResults: SpeechRecognitionResult[] = [
      { text: 'Hello', delay: 1000 },
      { text: 'Hello world', delay: 2000 },
      { text: 'Hello world this', delay: 3000 },
      { text: 'Hello world this is', delay: 4000 },
      { text: 'Hello world this is a', delay: 5000 },
      { text: 'Hello world this is a test', delay: 6000 }
    ];

    const processNextResult = () => {
      if (!this.isListening || this.currentRecognitionIndex >= simulatedResults.length) {
        if (this.isListening) {
          // Auto-stop after simulation completes
          this.isRecording = false;
          this.stopVoiceRecognition();
        }
        return;
      }

      const result: SpeechRecognitionResult = simulatedResults[this.currentRecognitionIndex];
      this.speechRecognitionTimer = setTimeout(() => {
        if (this.isListening) {
          this.recognizedText = result.text;
          console.info('Speech recognition result:', result.text);
          this.currentRecognitionIndex++;
          processNextResult();
        }
      }, result.delay - (this.currentRecognitionIndex > 0 ? simulatedResults[this.currentRecognitionIndex - 1].delay : 0));
    };

    processNextResult();
  }

  // Enhanced microphone click handler
  private handleMicrophoneClick(): void {
    if (this.isRecording) {
      // Stop recording
      this.isRecording = false;
      this.stopVoiceRecognition();
      console.info('Voice typing stopped by user');
    } else {
      // Start recording
      this.isRecording = true;
      this.showEmojiPanel = false;
      this.resetInactivityTimer();
      this.startVoiceRecognition();
      console.info('Voice typing started');
    }
  }

  // Handle voice interruption with popup
  private handleVoiceInterruption(interruptionType: 'manual' | 'clipboard' | 'error'): void {
    if (this.isRecording) {
      this.isRecording = false;
      this.stopVoiceRecognition();

      let message = '';
      switch (interruptionType) {
        case 'manual':
          message = getVoiceInterruptionMessage(this.currentLanguage) + ' - ' +
            (this.currentLanguage === 'en' ? 'Manual input' :
              this.currentLanguage === 'pl' ? 'Wpis rÄ™czny' :
                this.currentLanguage === 'it' ? 'Input manuale' :
                  this.currentLanguage === 'ar' ? 'Ø¥Ø¯Ø®Ø§Ù„ ÙŠØ¯ÙˆÙŠ' :
                    this.currentLanguage === 'fa' ? 'ÙˆØ±ÙˆØ¯ÛŒ Ø¯Ø³ØªÛŒ' : 'Manual input');
          break;
        case 'clipboard':
          message = getVoiceInterruptionMessage(this.currentLanguage) + ' - ' +
            (this.currentLanguage === 'en' ? 'Clipboard access' :
              this.currentLanguage === 'pl' ? 'DostÄ™p do schowka' :
                this.currentLanguage === 'it' ? 'Accesso agli appunti' :
                  this.currentLanguage === 'ar' ? 'Ø§Ù„ÙˆØµÙˆÙ„ Ø¥Ù„Ù‰ Ø§Ù„Ø­Ø§ÙØ¸Ø©' :
                    this.currentLanguage === 'fa' ? 'Ø¯Ø³ØªØ±Ø³ÛŒ Ø¨Ù‡ Ú©Ù„ÛŒÙ¾ Ø¨ÙˆØ±Ø¯' : 'Clipboard access');
          break;
        case 'error':
          message = getVoiceRecognitionError(this.currentLanguage);
          break;
      }

      console.info('Voice typing interrupted:', message);
      this.showVoiceInterruptionPopup(message);
    }
  }

  onPageShow(): void {
    console.info('OpenBoard Keyboard: UI onPageShow called');
    this.availableLanguages = ALLOWED_LANGUAGES.map((c: string) => c as LanguageCode);
    if (!this.availableLanguages.includes(this.currentLanguage)) {
      this.currentLanguage = this.availableLanguages[0];
    }
    this.startInactivityTimer();
  }

  aboutToAppear(): void {
    console.info('OpenBoard Keyboard: UI aboutToAppear called');
    keyboardController.setEnterKeyTypeCallback((enterKeyType: number) => {
      this.updateEnterKeyLabel(enterKeyType);
    });
    this.updateEnterKeyLabel(keyboardController.getCurrentEnterKeyType());
  }

  aboutToDisappear(): void {
    if (this.rapidDeleteTimer !== -1) {
      clearInterval(this.rapidDeleteTimer);
    }
    if (this.inactivityTimer !== -1) {
      clearTimeout(this.inactivityTimer);
    }
    if (this.speechRecognitionTimer !== -1) {
      clearTimeout(this.speechRecognitionTimer);
    }
    if (this.interruptionPopupTimer !== -1) {
      clearTimeout(this.interruptionPopupTimer);
    }
    // Clean up speech recognition
    if (this.isRecording) {
      this.stopVoiceRecognition();
    }
  }

  private startInactivityTimer(): void {
    if (this.inactivityTimer !== -1) {
      clearTimeout(this.inactivityTimer);
    }
    this.inactivityTimer = setTimeout(() => {
      const timeSinceLastActivity = Date.now() - this.lastTypingActivity;
      if (!this.isRecording && !this.showEmojiPanel && timeSinceLastActivity >= 5000) {
        this.showPreTypingToolbar = true;
      }
      this.startInactivityTimer(); // Continue checking
    }, 1000); // Check every second
  }

  private resetInactivityTimer(): void {
    this.lastTypingActivity = Date.now();
    this.showPreTypingToolbar = false;
  }

  private updateEnterKeyLabel(enterKeyType: number): void {
    switch (enterKeyType) {
      case inputMethodEngine.ENTER_KEY_TYPE_GO:
        this.enterKeyLabel = 'Go';
        break;
      case inputMethodEngine.ENTER_KEY_TYPE_SEARCH:
        this.enterKeyLabel = 'Search';
        break;
      case inputMethodEngine.ENTER_KEY_TYPE_SEND:
        this.enterKeyLabel = 'Send';
        break;
      case inputMethodEngine.ENTER_KEY_TYPE_NEXT:
        this.enterKeyLabel = 'Next';
        break;
      case inputMethodEngine.ENTER_KEY_TYPE_DONE:
        this.enterKeyLabel = 'Done';
        break;
      case inputMethodEngine.ENTER_KEY_TYPE_UNSPECIFIED:
      default:
        this.enterKeyLabel = 'Enter';
        break;
    }
  }

  private handleRapidDeleteStart(): void {
    if (this.rapidDeleteTimer !== -1) {
      clearInterval(this.rapidDeleteTimer);
    }
    this.rapidDeleteTimer = setInterval(() => {
      keyboardController.deleteForward(1);
      this.onBackspaceTyped();
    }, 100);
  }

  private handleRapidDeleteEnd(): void {
    if (this.rapidDeleteTimer !== -1) {
      clearInterval(this.rapidDeleteTimer);
      this.rapidDeleteTimer = -1;
    }
  }

  private updatePopupMetrics(touchPosition: Position): void {
    if (this.longPressInfo && this.longPressInfo.key.secondaryValue) {
      this.hoveredChar = this.longPressInfo.key.secondaryValue.split(',')[0];
      this.popupPosition = {
        x: this.longPressInfo.initialPosition.x - (this.longPressInfo.key.secondaryValue.split(',').length * this.popupKeyWidth / 2),
        y: this.longPressInfo.initialPosition.y - 70
      };
    }
  }

  private handleLongPress(key: KeyData, position: Position): void {
    if (key.action === KeyAction.Shift) {
      this.shiftState = ShiftState.CapsLock;
      return;
    }
    if (key.secondaryValue) {
      this.longPressInfo = { key: key, initialPosition: position };
      this.updatePopupMetrics(position);
    }
  }

  private handleLongPressDrag(position: Position): void {
    if (!this.longPressInfo || !this.longPressInfo.key.secondaryValue) return;

    const secondaryValues = this.longPressInfo.key.secondaryValue.split(',');
    const popupWidth = secondaryValues.length * this.popupKeyWidth;
    const startX = this.popupPosition.x;

    const relativeX = position.x - startX;
    let index = Math.floor(relativeX / this.popupKeyWidth);

    if (index < 0) index = 0;
    if (index >= secondaryValues.length) index = secondaryValues.length - 1;

    this.hoveredChar = secondaryValues[index];
  }

  private handleLongPressEnd(): void {
    if (this.longPressInfo && this.hoveredChar) {
      keyboardController.insertText(this.hoveredChar);
      this.onTextTyped(this.hoveredChar);
    }
    this.longPressInfo = null;
    this.hoveredChar = null;
  }

  handleKeyPress(key: KeyData): void {
    if (key.action !== KeyAction.EMOJI_PANEL) {
      this.resetInactivityTimer();
    }

    if (this.isRecording) {
      this.handleVoiceInterruption('manual');
    }

    if (key.action === KeyAction.EMOJI_PANEL) {
      this.showEmojiPanel = !this.showEmojiPanel;
      return;
    }

    switch (key.action) {
      case KeyAction.Char:
        let text = (this.currentLanguage !== 'ar' && this.currentLanguage !== 'fa' && (this.shiftState === ShiftState.On || this.shiftState === ShiftState.CapsLock))
          ? key.shiftValue ?? key.mainValue
          : key.mainValue;
        keyboardController.insertText(text);
        this.onTextTyped(text);
        if (this.shiftState === ShiftState.On) {
          this.shiftState = ShiftState.Off;
        }
        break;
      case KeyAction.Space:
        keyboardController.insertText(' ');
        this.onBoundaryTyped(' ');
        break;
      case KeyAction.Enter:
        keyboardController.sendEnterKey();
        this.onBoundaryTyped('\n');
        break;
      case KeyAction.Backspace:
        keyboardController.deleteForward(1);
        this.onBackspaceTyped();
        break;
      case KeyAction.Shift:
        const now = Date.now();
        if (this.shiftState === ShiftState.CapsLock) {
          this.shiftState = ShiftState.Off;
          this.lastShiftTapTs = now;
          break;
        }
        if (now - this.lastShiftTapTs < 400) {
          this.shiftState = ShiftState.CapsLock;
          this.lastShiftTapTs = 0;
          break;
        }
        this.shiftState = (this.shiftState === ShiftState.Off) ?
          ShiftState.On : ShiftState.Off;
        this.lastShiftTapTs = now;
        break;
      case KeyAction.SwitchAlphabet:
      case KeyAction.SwitchSymbols:
        this.keyboardLayout = (this.keyboardLayout === KeyboardLayout.Alphabet) ?
          KeyboardLayout.Symbols1 : KeyboardLayout.Alphabet;
        break;
      case KeyAction.SwitchSymbolsAlt:
        this.keyboardLayout = KeyboardLayout.Symbols2;
        break;
    }
  }

  // PASTE CURRENT CLIPBOARD ITEM ONLY
  private async handleClipboardClick(): Promise<void> {
    this.resetInactivityTimer();

    if (this.isRecording) {
      this.handleVoiceInterruption('clipboard');
    }

    try {
      const systemPasteboard = pasteboard.getSystemPasteboard();
      const hasData = systemPasteboard.hasDataSync();

      if (hasData) {
        const data = await systemPasteboard.getData();
        const text = data.getPrimaryText();

        if (text && text.length > 0) {
          keyboardController.insertText(text);
          this.onTextTyped(text);
          console.info('OpenBoard: Pasted clipboard text');
        }
      }
    } catch (e) {
      console.error('OpenBoard: Clipboard paste failed', e);
    }
  }

  handleSwipe(direction: LayoutSwipeDirection): void {
    if (this.availableLanguages.length <= 1) {
      console.warn('OpenBoard Keyboard: Only one language enabled, cannot switch.');
      return;
    }

    let currentIndex = this.availableLanguages.indexOf(this.currentLanguage);

    if (direction === LayoutSwipeDirection.Right) {
      currentIndex = (currentIndex - 1 + this.availableLanguages.length) % this.availableLanguages.length;
    } else {
      currentIndex = (currentIndex + 1) % this.availableLanguages.length;
    }

    this.currentLanguage = this.availableLanguages[currentIndex];
    console.info('OpenBoard Keyboard: Switched to language:', this.currentLanguage);
  }

  private updateSuggestions(): void {
    try {
      const list = predictionModel.predict(this.currentLanguage, this.previousWord, this.currentWord, 3);
      this.suggestions = [list[0] ?? '', list[1] ?? '', list[2] ?? ''];
    } catch (e) {
      console.warn('Prediction model error:', e);
      this.suggestions = ['', '', ''];
    }
  }

  private isBoundaryChar(ch: string): boolean {
    if (!ch) return false;
    const boundaries = [' ', '\n', ',', '.', '!', '?', ';', ':', '/', '\\', '-', '_', '"', "'", '(', ')', '[', ']', '<', '>'];
    return boundaries.indexOf(ch) >= 0;
  }

  private onTextTyped(text: string): void {
    if (!text) return;
    if (this.isBoundaryChar(text)) {
      this.onBoundaryTyped(text);
      return;
    }
    this.currentWord = this.currentWord + text;
    this.updateSuggestions();
    this.resetInactivityTimer();
  }

  private onBoundaryTyped(_: string): void {
    if (this.currentWord) {
      predictionModel.recordWord(this.currentLanguage, this.previousWord, this.currentWord);
      this.previousWord = this.currentWord;
      this.currentWord = '';
    }
    this.updateSuggestions();
    this.resetInactivityTimer();
  }

  private onBackspaceTyped(): void {
    if (this.currentWord && this.currentWord.length > 0) {
      this.currentWord = this.currentWord.substring(0, this.currentWord.length - 1);
      this.updateSuggestions();
      this.resetInactivityTimer();
    }

    // Show pre-typing toolbar when all text is deleted
    if (this.currentWord.length === 0 && this.previousWord === '') {
      this.showPreTypingToolbar = true;
    }
  }

  private pickSuggestion(word: string): void {
    this.resetInactivityTimer();
    keyboardController.deleteForward(this.currentWord.length);
    keyboardController.insertText(word);
    keyboardController.insertText(' ');

    this.onBoundaryTyped(' ');
    this.previousWord = word;
    this.currentWord = '';
    this.updateSuggestions();
  }

  private getScreenWidthVp(): number {
    try {
      const displayInfo = display.getDefaultDisplaySync();
      return displayInfo.width / 3;
    } catch (e) {
      console.error('Failed to get screen width:', e);
      return 360;
    }
  }

  // Build different toolbar variants using @Builder
  @Builder
  buildStandardToolbar() {
    Row({ space: 3 }) {
      // CLOSE ICON
      Column() {
        Image($r('app.media.close_icon'))
          .width(18)
          .height(18)
      }
      .width(34)
      .height(34)
      .justifyContent(FlexAlign.Center)
      .alignItems(HorizontalAlign.Center)
      .borderRadius(17)
      .backgroundColor(OpenBoardTheme.specialKey)
      .onClick(() => { keyboardController.hideKeyboard(); })

      // SUGGESTIONS
      Flex({ justifyContent: FlexAlign.Center, alignItems: ItemAlign.Center }) {
        Row({ space: 0 }) {
          ForEach(this.suggestions, (suggestion: string, index: number) => {
            Column() {
              Text(suggestion)
                .fontSize(16)
                .fontWeight(500)
                .fontColor(OpenBoardTheme.primaryText)
                .textAlign(TextAlign.Center)
                .maxLines(1).textOverflow({ overflow: TextOverflow.Ellipsis })
            }
            .justifyContent(FlexAlign.Center)
            .alignItems(HorizontalAlign.Center)
            .layoutWeight(1)
            .onClick(() => {
              if (suggestion) this.pickSuggestion(suggestion);
            })

            if (index < 2) {
              Text(' | ')
                .fontSize(16)
                .fontWeight(500)
                .fontColor(OpenBoardTheme.secondaryText)
            }
          })
        }
        .width('100%')
        .justifyContent(FlexAlign.Center)
        .alignItems(VerticalAlign.Center)
      }
      .layoutWeight(1)

      // MICROPHONE
      Column() {
        Image($r('app.media.mic_icon'))
          .width(20)
          .height(20)
          .fillColor(this.isRecording ? OpenBoardTheme.accent : OpenBoardTheme.primaryText)
      }
      .width(34)
      .height(34)
      .justifyContent(FlexAlign.Center)
      .alignItems(HorizontalAlign.Center)
      .borderRadius(17)
      .backgroundColor(this.isRecording ? OpenBoardTheme.accent : OpenBoardTheme.specialKey)
      .onClick(() => { this.handleMicrophoneClick(); })
    }
  }

  @Builder
  buildPreTypingToolbar() {
    Row({ space: 3 }) {
      // CLOSE ICON
      Column() {
        Image($r('app.media.close_icon'))
          .width(18)
          .height(18)
      }
      .width(34)
      .height(34)
      .justifyContent(FlexAlign.Center)
      .alignItems(HorizontalAlign.Center)
      .borderRadius(17)
      .backgroundColor(OpenBoardTheme.specialKey)
      .onClick(() => { keyboardController.hideKeyboard(); })

      // LEFT SPACER for centering
      Flex().layoutWeight(1)

      // CLIPBOARD ICON - CENTERED
      Column() {
        Image($r('app.media.clipboard_icon'))
          .width(20)
          .height(20)
          .fillColor(OpenBoardTheme.primaryText)
      }
      .width(34)
      .height(34)
      .justifyContent(FlexAlign.Center)
      .alignItems(HorizontalAlign.Center)
      .borderRadius(17)
      .backgroundColor(OpenBoardTheme.specialKey)
      .onClick(() => { this.handleClipboardClick(); })

      // RIGHT SPACER for centering
      Flex().layoutWeight(1)

      // MICROPHONE
      Column() {
        Image($r('app.media.mic_icon'))
          .width(20)
          .height(20)
          .fillColor(this.isRecording ? OpenBoardTheme.accent : OpenBoardTheme.primaryText)
      }
      .width(34)
      .height(34)
      .justifyContent(FlexAlign.Center)
      .alignItems(HorizontalAlign.Center)
      .borderRadius(17)
      .backgroundColor(this.isRecording ? OpenBoardTheme.accent : OpenBoardTheme.specialKey)
      .onClick(() => { this.handleMicrophoneClick(); })
    }
  }

  @Builder
  buildEmojiToolbar() {
    Row({ space: 3 }) {
      // RETURN TO KEYBOARD BUTTON
      Column() {
        Image($r('app.media.return_icon'))
          .width(20)
          .height(20)
          .fillColor(OpenBoardTheme.primaryText)
      }
      .width(34)
      .height(34)
      .justifyContent(FlexAlign.Center)
      .alignItems(HorizontalAlign.Center)
      .borderRadius(17)
      .backgroundColor(OpenBoardTheme.specialKey)
      .onClick(() => {
        this.showEmojiPanel = false;
      })

      // EMPTY SPACE
      Flex().layoutWeight(1)

      // EMPTY SPACE
      Flex().layoutWeight(1)
    }
  }

  @Builder
  buildVoiceToolbar() {
    Row({ space: 3 }) {
      // CLOSE ICON
      Column() {
        Image($r('app.media.close_icon'))
          .width(18)
          .height(18)
      }
      .width(34)
      .height(34)
      .justifyContent(FlexAlign.Center)
      .alignItems(HorizontalAlign.Center)
      .borderRadius(17)
      .backgroundColor(OpenBoardTheme.specialKey)
      .onClick(() => {
        keyboardController.hideKeyboard();
        if (this.isRecording) {
          this.stopVoiceRecognition();
        }
      })

      // VOICE RECORDING STATUS
      Flex({ justifyContent: FlexAlign.Center, alignItems: ItemAlign.Center }) {
        Row({ space: 6 }) {
          Image($r('app.media.mic_icon'))
            .width(18)
            .height(18)
            .fillColor(OpenBoardTheme.primaryText)

          Text(getVoiceDictationStatus(this.currentLanguage))
            .fontSize(16)
            .fontWeight(500)
            .fontColor(OpenBoardTheme.primaryText)

          // Show recognized text preview if available
          if (this.recognizedText) {
            Text(`: "${this.recognizedText}"`)
              .fontSize(14)
              .fontWeight(400)
              .fontColor(OpenBoardTheme.secondaryText)
              .maxLines(1)
              .textOverflow({ overflow: TextOverflow.Ellipsis })
          }
        }
        .width('100%')
        .justifyContent(FlexAlign.Center)
      }
      .layoutWeight(1)
    }
  }

  build() {
    Stack() {
      Column() {}
      .width('100%')
      .height('100%')
      .hitTestBehavior(HitTestMode.None)
      .backgroundColor(OpenBoardTheme.background)
      .animation({ duration: 200 })

      Column() {
        // MAIN TOOLBAR - CONDITIONAL RENDERING
        Row({ space: 3 }) {
          if (this.isRecording) {
            // Toolbar when typing with voice
            this.buildVoiceToolbar()
          } else if (this.showEmojiPanel) {
            // Toolbar when in emoji tab
            this.buildEmojiToolbar()
          } else if (this.showPreTypingToolbar) {
            // Toolbar before starting to type and after 5 sec of not typing
            this.buildPreTypingToolbar()
          } else {
            // Standard toolbar when typing
            this.buildStandardToolbar()
          }
        }
        .width('100%')
        .height(46)
        .padding({ left: 12, right: 12, top: 6, bottom: 6 })
        .backgroundColor(OpenBoardTheme.surface)
        .borderRadius(12)
        .border({ width: 1, color: OpenBoardTheme.divider })
        .shadow({ radius: 8, color: '#40000000', offsetY: 2 })

        // MAIN CONTENT
        if (!this.showEmojiPanel) {
          // Main keyboard
          Column({ space: 1 }) {
            ForEach(this.getCurrentLayout(), (row: KeyData[]) => {
              Row() {
                ForEach(row, (key: KeyData) => {
                  if (key.action === KeyAction.Spacer) {
                    Flex().layoutWeight(key.flex)
                  } else {
                    KeyView({
                      keyData: key,
                      shiftState: this.shiftState,
                      currentLanguage: this.currentLanguage,
                      availableLanguages: this.availableLanguages,
                      enterKeyLabel: this.enterKeyLabel,
                      onKeyPress: (k: KeyData): void => this.handleKeyPress(k),
                      onKeyLongPress: (k: KeyData, p: Position): void => this.handleLongPress(k, p),
                      onKeyLongPressDrag: (p: Position): void => this.handleLongPressDrag(p),
                      onKeyLongPressEnd: (): void => this.handleLongPressEnd(),
                      onKeyContinuousPressStart: (): void => this.handleRapidDeleteStart(),
                      onKeyContinuousPressEnd: (): void => this.handleRapidDeleteEnd(),
                      onSwipe: key.action === KeyAction.Space ? (direction: LayoutSwipeDirection): void => this.handleSwipe(direction) : undefined
                    })
                      .layoutWeight(key.flex)
                  }
                })
              }
              .width('100%')
              .layoutWeight(1)
            })
          }
          .layoutWeight(1)
          .padding({ left: 2, right: 2, bottom: 2 })
        } else {
          // Emoji Panel
          Column({ space: 10 }) {
            // Emoji Categories
            Scroll() {
              Row() {
                ForEach(EMOJI_CATEGORIES, (cat: string) => {
                  Text(cat)
                    .fontSize(14)
                    .fontWeight(500)
                    .fontColor(this.emojiCategory === cat ? OpenBoardTheme.accent : OpenBoardTheme.secondaryText)
                    .padding({ left: 16, right: 16, top: 8, bottom: 8 })
                    .backgroundColor(this.emojiCategory === cat ? OpenBoardTheme.surface : OpenBoardTheme.background)
                    .borderRadius(20)
                    .onClick(() => { this.emojiCategory = cat; })
                })
              }
              .padding({ left: 8, right: 8 })
            }

            // Emoji
            Scroll(this.emojiScroller) {
              Flex({ wrap: FlexWrap.Wrap, justifyContent: FlexAlign.Start, alignItems: ItemAlign.Start }) {
                ForEach(this.getEmojiList(this.emojiCategory), (emoji: string) => {
                  Text(emoji)
                    .fontSize(28)
                    .textAlign(TextAlign.Center)
                    .width('11%')
                    .height(46)
                    .onClick(() => {
                      keyboardController.insertText(emoji);
                      this.onTextTyped(emoji);
                    })
                })
              }
              .width('100%')
              .padding({ left: 8, right: 8 })
            }
            .scrollable(ScrollDirection.Vertical)
            .scrollBar(BarState.On)
            .onScrollFrameBegin((offset: number, state: ScrollState) => {
              return { offsetRemain: offset };
            })
          }
          .layoutWeight(1)
          .padding({ left: 2, right: 2, bottom: 2 })
        }
      }
      .alignSelf(ItemAlign.End)
      .backgroundColor(OpenBoardTheme.background)

      // Popups
      if (this.longPressInfo) {
        KeyPopup({ info: this.longPressInfo, hoveredChar: this.hoveredChar, keyWidth: this.popupKeyWidth })
          .position({ x: this.popupPosition.x, y: this.popupPosition.y })
          .zIndex(200)
      }

      if (this.singleCharPopupInfo) {
        SingleKeyPopup({ char: this.singleCharPopupInfo.char })
          .position({ x: this.singleCharPopupInfo.position.x - 25, y: this.singleCharPopupInfo.position.y - 70 })
          .zIndex(150)
      }

      if (this.languageIndicatorOpacity > 0) {
        LanguageIndicator({ languageName: getLanguageName(this.currentLanguage) })
          .opacity(this.languageIndicatorOpacity)
          .position({ x: (this.getScreenWidthVp() / 2) - 100, y: 150 })
          .zIndex(250)
      }

      // Voice interruption popup
      if (this.showInterruptionPopup) {
        VoiceInterruptionPopup({
          message: this.interruptionMessage,
          popupPosition: this.interruptionPopupPosition
        })
          .zIndex(300)
      }
    }
    .width('100%')
    .height('100%')
  }

  getCurrentLayout(): KeyData[][] {
    const insertEmojiKey = (layout: KeyData[][] | undefined): KeyData[][] => {
      if (!layout || layout.length < 4) return layout || [];
      const lastRow = layout[layout.length - 1].slice();
      const commaIndex = lastRow.findIndex(k => k.mainValue === ',' || k.mainValue === 'ØŒ');
      if (commaIndex !== -1 && lastRow[commaIndex + 1]?.action === KeyAction.Space) {
        lastRow.splice(commaIndex + 1, 0, EMOJI_KEY_DATA);
        const originalSpaceKey = lastRow[commaIndex + 2];
        if (originalSpaceKey) {
          const newSpaceKey: KeyData = {
            mainValue: originalSpaceKey.mainValue,
            shiftValue: originalSpaceKey.shiftValue,
            secondaryValue: originalSpaceKey.secondaryValue,
            action: originalSpaceKey.action,
            flex: Math.max(originalSpaceKey.flex - EMOJI_KEY_DATA.flex + 0.5, 3.5)
          };
          lastRow[commaIndex + 2] = newSpaceKey;
        }
        const newLayout = layout.slice(0, layout.length - 1);
        newLayout.push(lastRow);
        return newLayout;
      }
      return layout;
    };

    switch (this.keyboardLayout) {
      case KeyboardLayout.Alphabet:
        switch (this.currentLanguage) {
          case 'ar': return insertEmojiKey(arabicLayout);
          case 'en': return insertEmojiKey(englishLayout);
          case 'it': return insertEmojiKey(italianLayout);
          case 'pl': return insertEmojiKey(polishLayout);
          case 'fa': return insertEmojiKey(persianLayout);
          default: return insertEmojiKey(englishLayout);
        }
      case KeyboardLayout.Symbols1: return symbolsLayout1;
      case KeyboardLayout.Symbols2: return symbolsLayout2;
      default: return insertEmojiKey(englishLayout);
    }
  }

  private getEmojiList(category: string): string[] {
    switch (category) {
      case 'Smileys & Emotion':
        return ['ğŸ˜€','ğŸ˜','ğŸ˜‚','ğŸ¤£','ğŸ˜ƒ','ğŸ˜„','ğŸ˜…','ğŸ˜†','ğŸ˜‰','ğŸ˜Š','ğŸ˜‹','ğŸ˜','ğŸ¥°','ğŸ˜','ğŸ˜˜','ğŸ˜—','ğŸ˜™','ğŸ˜š','ğŸ¥²','ğŸ¥³','ğŸ¤©','ğŸ¤—','ğŸ¤”','ğŸ¤¨','ğŸ˜','ğŸ˜¶','ğŸ˜','ğŸ˜’','ğŸ™„','ğŸ˜¬','ğŸ¤¥','ğŸ˜Ÿ','ğŸ˜”','ğŸ˜¥','ğŸ¤¤','ğŸ˜«','ğŸ˜©','ğŸ¥º','ğŸ˜­','ğŸ˜¤','ğŸ˜®','ğŸ˜±','ğŸ˜³','ğŸ¤¯','ğŸ¥µ','ğŸ¥¶','ğŸ˜´','ğŸ˜µ','ğŸ˜·','ğŸ¤•','ğŸ¤¢','ğŸ¤®','ğŸ¤§','ğŸ˜‡','ğŸ˜ˆ','ğŸ‘¿','ğŸ‘¹','ğŸ‘º','ğŸ’€','ğŸ‘»','ğŸ‘½','ğŸ¤–','ğŸ’©','ğŸ˜º','ğŸ˜¸','ğŸ˜¹','ğŸ˜»','ğŸ˜¼','ğŸ˜½','ğŸ˜¾','ğŸ˜¿','ğŸ™€','ğŸ«¶','ğŸ‘','ğŸ‘','âœŠ','ğŸ‘Š','ğŸ¤','ğŸ¤','âœŒï¸','ğŸ«°','ğŸ¤Ÿ','ğŸ¤˜','ğŸ‘Œ','ğŸ¤Œ','ğŸ¤','ğŸ‘ˆ','ğŸ‘‰','ğŸ‘†','ğŸ‘‡','â˜ï¸','âœ‹','ğŸ¤š','ğŸ–ï¸','S','ğŸ’ª','ğŸ™','âœï¸','ğŸ’…','ğŸ‘‚','ğŸ‘ƒ','ğŸ‘ï¸','ğŸ§ ','ğŸ¦·','ğŸ¦´','ğŸ—£ï¸','ğŸ‘¤','ğŸ‘¥','ğŸ«‚'];
      case 'People':
        // Ludzie, czÄ™Å›ci ciaÅ‚a, zawody, rodziny
        return ['ğŸ‘¶','ğŸ‘§','ğŸ§’','ğŸ‘¦','ğŸ‘©','ğŸ§‘','ğŸ‘¨','ğŸ‘µ','ğŸ§“','ğŸ‘´','ğŸ‘±â€â™€ï¸','ğŸ‘±','ğŸ‘±â€â™‚ï¸','ğŸ‘®â€â™€ï¸','ğŸ‘®','ğŸ‘®â€â™‚ï¸','ğŸ‘·â€â™€ï¸','ğŸ‘·','ğŸ‘·â€â™‚ï¸','ğŸ§‘â€âš•ï¸','ğŸ‘¨â€âš•ï¸','ğŸ‘©â€âš•ï¸','ğŸ§‘â€ğŸ“','ğŸ‘¨â€ğŸ“','ğŸ‘©â€ğŸ“','ğŸ§‘â€ğŸ«','ğŸ‘¨â€ğŸ«','ğŸ‘©â€ğŸ«','ğŸ§‘â€âš–ï¸','ğŸ‘¨â€âš–ï¸','ğŸ‘©â€âš–ï¸','ğŸ§‘â€ğŸŒ¾','ğŸ‘¨â€ğŸŒ¾','ğŸ‘©â€ğŸŒ¾','ğŸ§‘â€ğŸ³','ğŸ‘¨â€ğŸ³','ğŸ‘©â€ğŸ³','ğŸ§‘â€ğŸ”§','ğŸ‘¨â€ğŸ”§','ğŸ‘©â€ğŸ”§','ğŸ§‘â€ğŸ­','ğŸ‘¨â€ğŸ­','ğŸ‘©â€ğŸ­','ğŸ§‘â€ğŸ’¼','ğŸ‘¨â€ğŸ’¼','ğŸ‘©â€ğŸ’¼','ğŸ§‘â€ğŸ”¬','ğŸ‘¨â€ğŸ”¬','ğŸ‘©â€ğŸ”¬','ğŸ§‘â€ğŸ’»','ğŸ‘¨â€ğŸ’»','ğŸ‘©â€ğŸ’»','ğŸ§‘â€ğŸ¤','ğŸ‘¨â€ğŸ¤','ğŸ‘©â€ğŸ¤','ğŸ§‘â€ğŸ¨','ğŸ‘¨â€ğŸ¨','ğŸ‘©â€ğŸ¨','ğŸ§‘â€âœˆï¸','ğŸ‘¨â€âœˆï¸','ğŸ‘©â€âœˆï¸','ğŸ§‘â€ğŸš€','ğŸ‘¨â€ğŸš€','ğŸ‘©â€ğŸš€','ğŸ§‘â€ğŸš’','ğŸ‘¨â€ğŸš’','ğŸ‘©â€ğŸš’','ğŸ’‚â€â™€ï¸','ğŸ’‚','ğŸ’‚â€â™‚ï¸','ğŸ•µï¸â€â™€ï¸','ğŸ•µï¸','ğŸ•µï¸â€â™‚ï¸','ğŸ¥·','ğŸ¤µâ€â™€ï¸','ğŸ¤µ','ğŸ¤µâ€â™‚ï¸','ğŸ‘°â€â™€ï¸','ğŸ‘°','ğŸ‘°â€â™‚ï¸','ğŸ¤°','ğŸ¤±','ğŸ§‘â€ğŸ¼','ğŸ‘¨â€ğŸ¼','ğŸ‘©â€ğŸ¼','ğŸ‘¼','ğŸ…','ğŸ¤¶','ğŸ§‘â€ğŸ„','ğŸ¦¸â€â™€ï¸','ğŸ¦¸','ğŸ¦¸â€â™‚ï¸','ğŸ¦¹â€â™€ï¸','ğŸ¦¹','ğŸ¦¹â€â™‚ï¸','ğŸ§™â€â™€ï¸','ğŸ§™','ğŸ§™â€â™‚ï¸','ğŸ§šâ€â™€ï¸','ğŸ§š','ğŸ§šâ€â™‚ï¸','ğŸ§›â€â™€ï¸','ğŸ§›','ğŸ§›â€â™‚ï¸','ğŸ§œâ€â™€ï¸','ğŸ§œ','ğŸ§œâ€â™‚ï¸','ğŸ§â€â™€ï¸','ğŸ§','ğŸ§â€â™‚ï¸','ğŸ§â€â™€ï¸','ğŸ§','ğŸ§â€â™‚ï¸','ğŸ§Ÿâ€â™€ï¸','ğŸ§Ÿ','ğŸ§Ÿâ€â™‚ï¸','ğŸš¶â€â™€ï¸','ğŸš¶','ğŸš¶â€â™‚ï¸','ğŸƒâ€â™€ï¸','ğŸƒ','ğŸƒâ€â™‚ï¸','ğŸ•º','ğŸ’ƒ','ğŸ§‘â€ğŸ¦½','ğŸ‘¨â€ğŸ¦½','ğŸ‘©â€ğŸ¦½','ğŸ§‘â€ğŸ¦¼','ğŸ‘¨â€ğŸ¦¼','ğŸ‘©â€ğŸ¦¼','ğŸ§â€â™€ï¸','ğŸ§','ğŸ§â€â™‚ï¸',' sitting','ğŸ§â€â™€ï¸','ğŸ§','ğŸ§â€â™‚ï¸',' kneeling','ğŸ§‘â€ğŸ¦¯','ğŸ‘¨â€ğŸ¦¯','ğŸ‘©â€ğŸ¦¯','ğŸ§‘â€ standing','ğŸ‘¨â€ standing','ğŸ‘©â€ standing','ğŸ‘©â€â¤ï¸â€ğŸ‘¨','ğŸ‘¨â€â¤ï¸â€ğŸ‘¨','ğŸ‘©â€â¤ï¸â€ğŸ‘©','familia','ğŸ’‹','ğŸ’˜','ğŸ’','ğŸ’–','ğŸ’—','ğŸ’“','ğŸ’','ğŸ’•','ğŸ§¡','ğŸ’›','ğŸ’š','ğŸ’™','ğŸ’œ','ğŸ¤','ğŸ–¤','ğŸ¤','ğŸ’¯','ğŸ’¢','ğŸ’¥','ğŸ’«','ğŸ’¦','ğŸ’¨','ğŸ’¬','ğŸ‘ï¸â€ğŸ—¨ï¸','ğŸ’­','ğŸ’¡','ğŸ”¥'];
      case 'Animals & Nature':
        // ZwierzÄ™ta, roÅ›liny, pogoda, krajobrazy
        return ['ğŸ¶','ğŸ±','ğŸ­','ğŸ¹','ğŸ°','ğŸ¦Š','ğŸ»','ğŸ¼','ğŸ¨','ğŸ¯','ğŸ¦','ğŸ®','ğŸ·','ğŸ½','ğŸ¸','ğŸµ','ğŸ’','ğŸ¦','ğŸ”','ğŸ§','ğŸ¦','ğŸ¤','ğŸ£','ğŸ¥','ğŸ¦†','ğŸ¦¢','ğŸ¦…','ğŸ¦‰','ğŸ¦©',' peacock',' parrot','ğŸ•Šï¸','ğŸº','ğŸ—','ğŸ´','ğŸ¦“','ğŸ¦Œ','ğŸ¦',' hippopotamus','ğŸ¦’','ğŸª','ğŸ«','ğŸ˜','ğŸ¦¥','ğŸ¦¦','ğŸ¦¨','ğŸ¦”','ğŸ¿ï¸','ğŸ','ğŸ€','ğŸ‡','ğŸˆ','ğŸ‰','ğŸ²','ğŸŠ','ğŸ¢','ğŸ','ğŸ¦','ğŸ¦–','ğŸ¦•','ğŸ‹','ğŸ³','ğŸ¬','ğŸ ','ğŸ¡','ğŸ¦ˆ','ğŸ™','ğŸ¦‘','ğŸ¦','ğŸ¦€','ğŸ¦',' snail','ğŸ¦‹','ğŸ›','ğŸœ','ğŸ','ğŸ','ğŸ¦—','ğŸ•·ï¸','ğŸ¦‚','ğŸ¦ ','ğŸ’','ğŸŒ¸','ğŸŒ¼','ğŸŒ»','ğŸŒ·','ğŸŒ¹','ğŸ¥€','ğŸŒº','ğŸª´','ğŸŒ²','ğŸŒ³','ğŸŒ´','ğŸŒµ','ğŸŒ¾','ğŸŒ¿','â˜˜ï¸','ğŸ€','ğŸ','ğŸ‚','ğŸƒ','ğŸ„','ğŸŒ°','ğŸŒ','ğŸŒ','ğŸŒ','ğŸŒ‘','ğŸŒ•','ğŸŒ“','ğŸŒ”','ğŸŒ–','ğŸŒ—','ğŸŒ˜','ğŸŒ™','â­','ğŸŒŸ','âœ¨','âš¡','ğŸ”¥','â˜€ï¸','ğŸŒ¤ï¸','â›…','ğŸŒ¥ï¸','ğŸŒ¦ï¸','â˜ï¸','ğŸŒ¨ï¸','ğŸŒ§ï¸','â›ˆï¸','ğŸŒ©ï¸','â„ï¸','â›„','ğŸŒ¬ï¸','ğŸ’¨','ğŸŒªï¸','ğŸŒ€','ğŸŒˆ','ğŸŒŠ','ğŸ’§','â˜”','â˜‚ï¸','ğŸ’¦'];
      case 'Food & Drink':
        // Owoce, warzywa, dania, sÅ‚odycze, napoje
        return ['ğŸ','ğŸ','ğŸ','ğŸŠ','ğŸ‹','ğŸŒ','ğŸ‰','ğŸ‡','ğŸ“','ğŸ«','ğŸ’','ğŸ‘','ğŸ¥­','ğŸ','ğŸ¥¥','ğŸ¥','ğŸ…','ğŸ†','ğŸ¥•','ğŸŒ½','ğŸŒ¶ï¸','ğŸ¥’','ğŸ¥¦','ğŸ«‘','ğŸ§…','ğŸ§„','ğŸ¥”','ğŸ ','ğŸ¥','ğŸ','ğŸ¥–','ğŸ¥¨','ğŸ¥¯','ğŸ¥','ğŸ§‡','ğŸ§€','ğŸ¥©','ğŸ—','ğŸ–','ğŸ¥“','ğŸ”','ğŸŸ','ğŸ•','ğŸŒ­','ğŸ¥ª','ğŸŒ®','ğŸŒ¯','ğŸ¥™','ğŸ¥š','ğŸ³','ğŸ¥˜','ğŸ²','ğŸ¥£','ğŸ¥—',' popcorn','ğŸ§ˆ','ğŸ§‚','ğŸ¥«','ğŸ±','ğŸ™','ğŸš','ğŸ˜','ğŸ¥','ğŸ£','ğŸ¤','ğŸœ','ğŸ','ğŸ›','ğŸ ','ğŸ¢','ğŸ¡','ğŸ¥Ÿ','ğŸ¥ ','ğŸ¥¡','ğŸ¦','ğŸ§','ğŸ¨','ğŸ©','ğŸª','ğŸ‚','ğŸ°','ğŸ§','ğŸ¥§','ğŸ«','ğŸ¬','ğŸ­','ğŸ®','ğŸ¯','ğŸ¼','ğŸ¥›','â˜•','ğŸµ','ğŸ¥¤','ğŸ§‹','ğŸ«—','ğŸº','ğŸ»','ğŸ·','ğŸ¥‚','ğŸ¾','ğŸ¥ƒ','ğŸ¸','ğŸ¹','ğŸ¶','ğŸ§Š','ğŸ¥£','ğŸ´','ğŸ¥„','ğŸ¥¢','ğŸ¥¡','ğŸ§§'];
      case 'Activity & Event':
        // Sport, hobby, muzyka, Å›wiÄ™ta, wydarzenia
        return ['âš½','ğŸ€','ğŸˆ','âš¾','ğŸ¥','ğŸ¾','ğŸ','ğŸ‰','ğŸ±','ğŸ“',' badminton','ğŸ¥Š','ğŸ¥‹','â›¸ï¸','ğŸ¿','ğŸ‚','â›·ï¸','ğŸ¹','ğŸ¯','ğŸ³','â›³','ğŸ£','ğŸŠâ€â™‚ï¸','ğŸš´â€â™‚ï¸','ğŸƒâ€â™‚ï¸','ğŸš¶â€â™‚ï¸','ğŸ©°','ğŸ¤','ğŸ§','ğŸ¼','ğŸ¹','ğŸ¥','ğŸ¸','ğŸº','ğŸ»','ğŸ¬','ğŸ­','ğŸ–¼ï¸','ğŸ¨','ğŸ§µ','ğŸ§¶','ğŸ²','â™Ÿï¸','ğŸ§©','ğŸ§¸','ğŸ®','ğŸ•¹ï¸','ğŸ°','ğŸ¡','ğŸ¢','ğŸ ','ğŸŠ','ğŸ‰','ğŸ','ğŸˆ','ğŸ€','ğŸ—ï¸','ğŸŸï¸','ğŸ«','ğŸ–ï¸','ğŸ†','ğŸ…','ğŸ¥‡','ğŸ¥ˆ','ğŸ¥‰','ğŸ””','ğŸ„','ğŸ…','ğŸƒ','ğŸ‘»','ğŸ‚','ğŸ’','ğŸ’','ğŸ’°','ğŸ’²','ğŸ’¸','ğŸ’µ','ğŸ’¶','ğŸ’·','ğŸ’´','ğŸ’³','ğŸ§¾','ğŸ”—','ğŸ”’','ğŸ”“','ğŸ”‘'];
      case 'Travel & Places':
        // Pojazdy, miejsca, budynki
        return ['ğŸš—','ğŸš•','ğŸš™','ğŸšŒ','ğŸš','ğŸï¸','ğŸš“','ğŸš‘','ğŸš’','ğŸš','ğŸšš','ğŸš›','ğŸšœ','ğŸï¸','ğŸ›µ','ğŸš²','ğŸ›´','ğŸš¨','â›½','ğŸ›£ï¸','ğŸ›¤ï¸','ğŸš','ğŸš¦','ğŸš¥','ğŸš§','anchor','ğŸš¢','â›´ï¸','ğŸš¤','ğŸ›¥ï¸','ğŸ›³ï¸','ğŸš€','ğŸ›¸','ğŸš','ğŸš‚','ğŸšƒ','ğŸš‹','ğŸšŒ','ğŸš†','ğŸš‡','ğŸšŠ','ğŸš‰','âœˆï¸','ğŸ›«','ğŸ›¬','ğŸ’º','ğŸ¨','motel','house','ğŸ ','ğŸ¡','ğŸ˜ï¸','ğŸšï¸','ğŸ—ï¸','ğŸ¢','ğŸ­','ğŸ¬','ğŸ£','éƒµ','ğŸ¦','ğŸ¥','ğŸ«','ğŸ¤','â›ª','ğŸ•Œ','ğŸ•','ğŸ•‹',' fountain','â›²','ğŸ—¼',' statue of liberty','ğŸ—¾','ğŸŒ‹',' mount fuji','ğŸ—»',' at the sea','ğŸ–ï¸','desert','island','â›º','ğŸŒƒ','ğŸ™ï¸','ğŸŒ„','ğŸŒ…','ğŸŒ‡','ğŸŒ†','ğŸŒ‰',' Milky Way','ğŸŒ ','ğŸ‡','ğŸ†'];
      case 'Objects':
        // Przedmioty, narzÄ™dzia, ubrania, elektronika
        return ['âŒš','ğŸ“±','ğŸ’»','âŒ¨ï¸','ğŸ–¨ï¸','ğŸ–±ï¸','ğŸ“·','ğŸ“¸','ğŸ“¹','ğŸ“¼','ğŸ’¿','ğŸ“€','ğŸ“»','ğŸ“º','ğŸ“','ğŸ“ ','ğŸ”‹','ğŸ”Œ','ğŸ’¡','ğŸ”¦','ğŸ•¯ï¸','ğŸ—‘ï¸','ğŸ›’','âœ‰ï¸','ğŸ“§','ğŸ“©','ğŸ“¨','ğŸ“¤','ğŸ“¥','ğŸ“¦','ğŸ“«','ğŸ“ª','ğŸ“¬','ğŸ“­','ğŸ“®','ğŸ“œ','ğŸ“ƒ','ğŸ“„','ğŸ“‘','ğŸ“…','ğŸ—“ï¸','ğŸ“‡','ğŸ“ˆ','ğŸ“‰','ğŸ“Š','ğŸ“‹','ğŸ“Œ','ğŸ“','ğŸ“','ğŸ–‡ï¸','ğŸ“','ğŸ“','âœ‚ï¸','ğŸªš','ğŸ”¨','â›ï¸','ğŸª“','ğŸ”ª','ğŸ”«','ğŸ©º','ğŸ§ª','ğŸŒ¡ï¸','ğŸ’‰','ğŸ’Š','ğŸ©¹','ğŸšª','ğŸª‘','ğŸ›‹ï¸','ğŸ›ï¸','ğŸ›€','ğŸ§¼','ğŸ§½','ğŸ§º','ğŸš½','ğŸš¿','ğŸ›','ğŸª ','ğŸ§´','ğŸ‘š','ğŸ‘•','ğŸ‘–','ğŸ‘”','ğŸ‘—','ğŸ‘™','ğŸ‘˜','ğŸ¥»','ğŸ©±','ğŸ©²','ğŸ©³','ğŸ§¥','ğŸ¥¼','ğŸ§£','ğŸ§¤','ğŸ§¢','ğŸ‘’','ğŸ“','ğŸ‘‘','ğŸ’','ğŸ’','ğŸ’„','ğŸ’…','ğŸª®','ğŸª’','ğŸª¥','ğŸª£','ğŸª¤','ğŸªŸ','ğŸªœ','ğŸª','ğŸªš','ğŸª›','ğŸ› ï¸','âš™ï¸','ğŸ§±','â›“ï¸','ğŸ”—','ğŸ“','ğŸ§®'];
      case 'Symbols':
        // Znaki, strzaÅ‚ki, cyfry, emotikony tekstowe
        return ['â¤ï¸','ğŸ§¡','ğŸ’›','ğŸ’š','ğŸ’™','ğŸ’œ','ğŸ–¤','ğŸ¤','ğŸ¤','ğŸ’”','â—ï¸','â“','â€¼ï¸','â‰ï¸','âœ…','âŒ','âœ”ï¸','âœ–ï¸','â•','â–','â—','â™¾ï¸','Â©ï¸','Â®ï¸','â„¢ï¸','â„ ','Â®ï¸','â„¢ï¸','Â©ï¸','Â®ï¸','â„¢ï¸','â„ ','#ï¸âƒ£','*ï¸âƒ£','0ï¸âƒ£','1ï¸âƒ£','2ï¸âƒ£','3ï¸âƒ£','4ï¸âƒ£','5ï¸âƒ£','6ï¸âƒ£','7ï¸âƒ£','8ï¸âƒ£','9ï¸âƒ£','ğŸ”Ÿ','â¬†ï¸','â¬‡ï¸','â¬…ï¸','â¡ï¸','â†–ï¸','â†—ï¸','â†˜ï¸','â†™ï¸','â†•ï¸','â†”ï¸','â†©ï¸','â†ªï¸','â¤´ï¸','â¤µï¸','ğŸ”„','â—€ï¸','â–¶ï¸','ğŸ”¼','ğŸ”½','âï¸','â¿','â™»ï¸','âšœï¸','ğŸ”±','âš ï¸','â›”','ğŸš«','ğŸš­','ğŸš³','ğŸš±','ğŸš·','ğŸ“µ','ğŸ”',' P','ğŸ…¿ï¸','ğŸš¸','ğŸˆ¯','ğŸˆš','ğŸˆ¶','ğŸˆ²','ğŸˆ¹','ğŸˆº','ğŸˆ·ï¸','ğŸˆ‚ï¸','ğŸ‰‘','ğŸˆ´','ğŸˆ³','ãŠ—ï¸','ãŠ™ï¸','âŒ','â­•','ğŸ›‘','â›‘ï¸','ğŸ‘‘','ğŸ”‘','ğŸ””','ğŸ”•','ğŸ¶','ğŸµ','â•','â–','â—','âœ–ï¸','â¿','âœ”ï¸','â˜‘ï¸','âœ…','â­•','âŒ','ğŸ›‘','âš ï¸','â—','â“'];
      case 'Flags':
        // Wybrane flagi
        return ['ğŸ³ï¸','ğŸ´','ğŸ','ğŸš©','ğŸ‡¦ğŸ‡«','ğŸ‡¦ğŸ‡½','ğŸ‡¦ğŸ‡±','ğŸ‡©ğŸ‡¿','ğŸ‡¦ğŸ‡¸','ğŸ‡¦ğŸ‡©','ğŸ‡¦ğŸ‡´','ğŸ‡¦ğŸ‡®','ğŸ‡¦ğŸ‡¶','ğŸ‡¦ğŸ‡¬','ğŸ‡¦ğŸ‡·','ğŸ‡¦ğŸ‡²','ğŸ‡¦ğŸ‡¼','ğŸ‡¦ğŸ‡º','ğŸ‡¦ğŸ‡¹','ğŸ‡¦ğŸ‡¿','ğŸ‡§ğŸ‡¸','ğŸ‡§ğŸ‡­','ğŸ‡§ğŸ‡©','ğŸ‡§ğŸ‡§','ğŸ‡§ğŸ‡¾','ğŸ‡§ğŸ‡ª','ğŸ‡§ğŸ‡¿','ğŸ‡§ğŸ‡¯','ğŸ‡§ğŸ‡²','ğŸ‡§ğŸ‡¹','ğŸ‡§ğŸ‡´','ğŸ‡§ğŸ‡¦','ğŸ‡§ğŸ‡¼','ğŸ‡§ğŸ‡·','ğŸ‡®ğŸ‡´','ğŸ‡»ğŸ‡¬','ğŸ‡§ğŸ‡³','ğŸ‡§ğŸ‡¬','ğŸ‡§ğŸ‡«','ğŸ‡§ğŸ‡®','ğŸ‡°ğŸ‡­','ğŸ‡¨ğŸ‡²','ğŸ‡¨ğŸ‡¦','ğŸ‡®ğŸ‡¨','ğŸ‡¨ğŸ‡»','ğŸ‡§ğŸ‡¶','ğŸ‡°ğŸ‡¾','ğŸ‡¨ğŸ‡«','ğŸ‡¹ğŸ‡©','ğŸ‡¨ğŸ‡±','ğŸ‡¨ğŸ‡³','ğŸ‡¨ğŸ‡½','ğŸ‡¨ğŸ‡¨','ğŸ‡¨ğŸ‡´','ğŸ‡°ğŸ‡²','ğŸ‡¨ğŸ‡¬','ğŸ‡¨ğŸ‡©','ğŸ‡¨ğŸ‡°','ğŸ‡¨ğŸ‡·','ğŸ‡­ğŸ‡·','ğŸ‡¨ğŸ‡º','ğŸ‡¨ğŸ‡¼','ğŸ‡¨ğŸ‡¾','ğŸ‡¨ğŸ‡¿','ğŸ‡©ğŸ‡°','ğŸ‡©ğŸ‡¯','ğŸ‡©ğŸ‡²','ğŸ‡©ğŸ‡´','ğŸ‡ªğŸ‡¨','ğŸ‡ªğŸ‡¬','ğŸ‡¸ğŸ‡»','ğŸ‡¬ğŸ‡¶','ğŸ‡ªğŸ‡·','ğŸ‡ªğŸ‡ª','ğŸ‡¸ğŸ‡¿','ğŸ‡ªğŸ‡¹','ğŸ‡ªğŸ‡º','ğŸ‡«ğŸ‡°','ğŸ‡«ğŸ‡´','ğŸ‡«ğŸ‡¯','ğŸ‡«ğŸ‡®','ğŸ‡«ğŸ‡·','ğŸ‡¬ğŸ‡«','ğŸ‡µğŸ‡«','ğŸ‡¹ğŸ‡«','ğŸ‡¬ğŸ‡¦','ğŸ‡¬ğŸ‡²','ğŸ‡¬ğŸ‡ª','ğŸ‡©ğŸ‡ª','ğŸ‡¬ğŸ‡­','ğŸ‡¬ğŸ‡®','ğŸ‡¬ğŸ‡·','ğŸ‡¬ğŸ‡±','ğŸ‡¬ğŸ‡©','ğŸ‡¬ğŸ‡µ','ğŸ‡¬ğŸ‡º','ğŸ‡¬ğŸ‡¹','ğŸ‡¬ğŸ‡¬','ğŸ‡¬ğŸ‡³','ğŸ‡¬ğŸ‡¼','ğŸ‡¬ğŸ‡¾','ğŸ‡­ğŸ‡¹','ğŸ‡­ğŸ‡³','ğŸ‡­ğŸ‡°','ğŸ‡­ğŸ‡º','ğŸ‡®ğŸ‡¸','ğŸ‡®ğŸ‡³','ğŸ‡®ğŸ‡©','ğŸ‡®ğŸ‡·','ğŸ‡®ğŸ‡¶','ğŸ‡®ğŸ‡ª','ğŸ‡®ğŸ‡²','ğŸ‡®ğŸ‡±','ğŸ‡®ğŸ‡¹','ğŸ‡¯ğŸ‡²','ğŸ‡¯ğŸ‡µ','ğŸ‡¯ğŸ‡ª','ğŸ‡¯ğŸ‡´','ğŸ‡°ğŸ‡¿','ğŸ‡°ğŸ‡ª','ğŸ‡°ğŸ‡®','ğŸ‡½ğŸ‡°','ğŸ‡°ğŸ‡¼','ğŸ‡°ğŸ‡¬','ğŸ‡±ğŸ‡¦','ğŸ‡±ğŸ‡»','ğŸ‡±ğŸ‡§','ğŸ‡±ğŸ‡¸','ğŸ‡±ğŸ‡·','ğŸ‡±ğŸ‡¾','ğŸ‡±ğŸ‡®','ğŸ‡±ğŸ‡¹','ğŸ‡±ğŸ‡º','ğŸ‡²ğŸ‡´','ğŸ‡²ğŸ‡¬','ğŸ‡²ğŸ‡¼','ğŸ‡²ğŸ‡¾','ğŸ‡²ğŸ‡»','ğŸ‡²ğŸ‡±','ğŸ‡²ğŸ‡¹','ğŸ‡²ğŸ‡­','ğŸ‡²ğŸ‡¶','ğŸ‡²ğŸ‡·','ğŸ‡²ğŸ‡º','ğŸ‡¾ğŸ‡¹','ğŸ‡²ğŸ‡½','ğŸ‡«ğŸ‡²','ğŸ‡²ğŸ‡©','ğŸ‡²ğŸ‡¨','ğŸ‡²ğŸ‡³','ğŸ‡²ğŸ‡ª','ğŸ‡²ğŸ‡¸','ğŸ‡²ğŸ‡¦','ğŸ‡²ğŸ‡¿','ğŸ‡²ğŸ‡²','ğŸ‡³ğŸ‡¦','ğŸ‡³ğŸ‡·','ğŸ‡³ğŸ‡µ','ğŸ‡³ğŸ‡±','ğŸ‡³ğŸ‡¨','ğŸ‡³ğŸ‡¿','ğŸ‡³ğŸ‡®','ğŸ‡³ğŸ‡ª','ğŸ‡³ğŸ‡¬','ğŸ‡³ğŸ‡º','ğŸ‡³ğŸ‡«','ğŸ‡°ğŸ‡µ','ğŸ‡²ğŸ‡°','ğŸ‡²ğŸ‡µ','ğŸ‡³ğŸ‡´','ğŸ‡´ğŸ‡²','ğŸ‡µğŸ‡°','ğŸ‡µğŸ‡¼','ğŸ‡µğŸ‡¸','ğŸ‡µğŸ‡¦','ğŸ‡µğŸ‡¬','ğŸ‡µğŸ‡¾','ğŸ‡µğŸ‡ª','ğŸ‡µğŸ‡­','ğŸ‡µğŸ‡³','ğŸ‡µğŸ‡±','ğŸ‡µğŸ‡¹','ğŸ‡µğŸ‡·','ğŸ‡¶ğŸ‡¦','ğŸ‡·ğŸ‡ª','ğŸ‡·ğŸ‡´','ğŸ‡·ğŸ‡º','ğŸ‡·ğŸ‡¼','ğŸ‡¸ğŸ‡½','ğŸ‡¼ğŸ‡¸','ğŸ‡¸ğŸ‡²','ğŸ‡¸ğŸ‡¹','ğŸ‡¸ğŸ‡¦','ğŸ‡¸ğŸ‡³','ğŸ‡·ğŸ‡¸','ğŸ‡¸ğŸ‡¨','ğŸ‡¸ğŸ‡±','ğŸ‡¸ğŸ‡¬','ğŸ‡¸ğŸ‡°','ğŸ‡¸ğŸ‡®','ğŸ‡¸ğŸ‡§','ğŸ‡¸ğŸ‡´','ğŸ‡¿ğŸ‡¦','ğŸ‡¬ğŸ‡¸','ğŸ‡°ğŸ‡·','ğŸ‡¸ğŸ‡¸','ğŸ‡ªğŸ‡¸','ğŸ‡±ğŸ‡°','ğŸ‡¸ğŸ‡©','ğŸ‡¸ğŸ‡·','ğŸ‡¸ğŸ‡¯','ğŸ‡¸ğŸ‡ª','ğŸ‡¨ğŸ‡­','ğŸ‡¸ğŸ‡¾','ğŸ‡¹ğŸ‡¼','ğŸ‡¹ğŸ‡¯','ğŸ‡¹ğŸ‡¿','ğŸ‡¹ğŸ‡­','ğŸ‡¹ğŸ‡±','ğŸ‡¹ğŸ‡¬','ğŸ‡¹ğŸ‡°','ğŸ‡¹ğŸ‡´','ğŸ‡¹ğŸ‡¹','ğŸ‡¹ğŸ‡³','ğŸ‡¹ğŸ‡·','ğŸ‡¹ğŸ‡²','ğŸ‡¹ğŸ‡¨','ğŸ‡¹ğŸ‡»','ğŸ‡ºğŸ‡¬','ğŸ‡ºğŸ‡¦','ğŸ‡¦ğŸ‡ª','ğŸ‡¬ğŸ‡§','ğŸ‡ºğŸ‡¸','ğŸ‡ºğŸ‡¾','ğŸ‡ºğŸ‡¿','ğŸ‡»ğŸ‡º','ğŸ‡»ğŸ‡¦','ğŸ‡»ğŸ‡ª','ğŸ‡»ğŸ‡³','ğŸ‡¼ğŸ‡«','ğŸ‡ªğŸ‡­','ğŸ‡¾ğŸ‡ª','ğŸ‡¿ğŸ‡²','ğŸ‡¿ğŸ‡¼'];
      default:
        return ['ğŸ™‚','ğŸ˜Š','ğŸ˜‚','ğŸ¤£'];
    }
  }
}
